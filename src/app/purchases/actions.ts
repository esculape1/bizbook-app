
'use server';

import { z } from 'zod';
import { db } from '@/lib/firebase-admin';
import { FieldValue } from 'firebase-admin/firestore';
import {
  addPurchase,
  getSuppliers,
  getProducts,
  updatePurchase as updatePurchaseInDB,
  getPurchaseById,
  updateProduct,
} from '@/lib/data';
import { revalidateTag } from 'next/cache';
import type { PurchaseItem, Purchase, Product } from '@/lib/types';
import { getSession } from '@/lib/session';

const purchaseItemSchema = z.object({
  productId: z.string().min(1, "Produit requis"),
  productName: z.string(),
  reference: z.string(),
  quantity: z.coerce.number().min(1, "Qté > 0"),
});

const purchaseSchema = z.object({
  supplierId: z.string().min(1, "Fournisseur requis"),
  date: z.date({ required_error: "Date requise" }),
  items: z.array(purchaseItemSchema).min(1, "Ajoutez au moins un produit."),
  premierVersement: z.coerce.number().min(0).default(0),
  deuxiemeVersement: z.coerce.number().min(0).default(0),
  transportCost: z.coerce.number().min(0).default(0),
  otherFees: z.coerce.number().min(0).default(0),
});

export async function createPurchase(formData: unknown) {
  const session = await getSession();
  if (session?.role !== 'Admin' && session?.role !== 'SuperAdmin') {
    return { message: "Action non autorisée." };
  }

  const validatedFields = purchaseSchema.safeParse(formData);
  if (!validatedFields.success) {
    return { message: 'Champs invalides. Impossible de créer l\'achat.' };
  }

  try {
    const { supplierId, date, items, transportCost, otherFees, premierVersement, deuxiemeVersement } = validatedFields.data;
    
    const suppliers = await getSuppliers();
    const products = await getProducts();

    const supplier = suppliers.find(s => s.id === supplierId);
    if (!supplier) {
      return { message: 'Fournisseur non trouvé.' };
    }
    
    const purchaseItems: PurchaseItem[] = items.map(item => {
      const product = products.find(p => p.id === item.productId);
      if (!product) throw new Error(`Produit non trouvé: ${item.productId}`);
      return {
        productId: item.productId,
        productName: product.name,
        reference: product.reference,
        quantity: item.quantity,
      };
    });

    const totalAmount = premierVersement + deuxiemeVersement + transportCost + otherFees;

    const newPurchaseData: Omit<Purchase, 'id'> = {
        purchaseNumber: '', // Will be generated by addPurchase
        supplierId,
        supplierName: supplier.name,
        date: date.toISOString(),
        items: purchaseItems,
        premierVersement,
        deuxiemeVersement,
        transportCost,
        otherFees,
        totalAmount,
        status: 'Pending',
    };
    
    await addPurchase(newPurchaseData);

    revalidateTag('purchases');
    revalidateTag('products');
    revalidateTag('dashboard-stats');
    return {};
  } catch (error) {
    console.error('Failed to create purchase:', error);
    const message = error instanceof Error ? error.message : 'Erreur DB: Impossible de créer l\'achat.';
    return { message };
  }
}

// Internal update function without status change logic
async function performPurchaseUpdate(id: string, purchaseData: Partial<Omit<Purchase, 'id'>>) {
    if (!db) throw new Error("La connexion à la base de données a échoué.");
    await updatePurchaseInDB(id, purchaseData);
}

export async function updatePurchase(id: string, purchaseNumber: string, formData: unknown) {
  const session = await getSession();
  if (session?.role !== 'Admin' && session?.role !== 'SuperAdmin') {
    return { message: "Action non autorisée." };
  }

  // Schema for editing doesn't include status
  const editPurchaseSchema = purchaseSchema.extend({});
  const validatedFields = editPurchaseSchema.safeParse(formData);

  if (!validatedFields.success) {
    console.log(validatedFields.error.flatten().fieldErrors);
    return { message: 'Champs invalides. Impossible de mettre à jour l\'achat.' };
  }
  
  try {
    const { supplierId, date, items, premierVersement, deuxiemeVersement, transportCost, otherFees } = validatedFields.data;
    
    const [originalPurchase, suppliers] = await Promise.all([
      getPurchaseById(id),
      getSuppliers()
    ]);
    
    if (!originalPurchase) return { message: 'Achat original non trouvé.' };
    if (session?.role !== 'SuperAdmin' && originalPurchase.status !== 'Pending') {
      return { message: 'Seuls les achats "En attente" peuvent être modifiés.' };
    }

    const supplier = suppliers.find(c => c.id === supplierId);
    if (!supplier) return { message: 'Fournisseur non trouvé.' };

    const products = await getProducts();
    const purchaseItems: PurchaseItem[] = items.map(item => {
      const product = products.find(p => p.id === item.productId);
      if (!product) throw new Error(`Produit non trouvé: ${item.productId}`);
      return { productId: item.productId, productName: product.name, reference: product.reference, quantity: item.quantity };
    });
    
    const totalAmount = premierVersement + deuxiemeVersement + transportCost + otherFees;

    const purchaseUpdateData: Partial<Omit<Purchase, 'id'>> = {
      purchaseNumber,
      supplierId,
      supplierName: supplier.name,
      date: date.toISOString(),
      items: purchaseItems,
      premierVersement,
      deuxiemeVersement,
      transportCost,
      otherFees,
      totalAmount,
    };
    
    await performPurchaseUpdate(id, purchaseUpdateData);

    revalidateTag('purchases');
    return {};
  } catch (error) {
    console.error('Failed to update purchase:', error);
    const message = error instanceof Error ? error.message : 'Erreur DB: Impossible de mettre à jour l\'achat.';
    return { message };
  }
}

export async function receivePurchase(id: string) {
    const session = await getSession();
    if (session?.role !== 'Admin' && session?.role !== 'SuperAdmin') {
      return { message: "Action non autorisée." };
    }
  
    if (!db) {
      throw new Error("La connexion à la base de données a échoué.");
    }
  
    try {
      const purchase = await getPurchaseById(id);
      
      if (!purchase) return { message: 'Achat non trouvé.' };
      if (purchase.status === 'Received') return { message: 'Cet achat a déjà été réceptionné.' };
      if (purchase.status === 'Cancelled') return { message: 'Cet achat est annulé et ne peut être réceptionné.' };
  
      await db.runTransaction(async (transaction) => {
        const purchaseRef = db.collection('purchases').doc(id);
        
        const productRefs = purchase.items.map(item => db.collection('products').doc(item.productId));
        const productDocs = await transaction.getAll(...productRefs);
        const productMap = new Map(productDocs.map(doc => [doc.id, doc.data() as Product]));

        transaction.update(purchaseRef, { status: 'Received' });

        for (const item of purchase.items) {
          const productRef = db.collection('products').doc(item.productId);
          const product = productMap.get(item.productId);
          
          if (product) {
            const stockUpdate: { quantityInStock: FirebaseFirestore.FieldValue, purchasePrice?: number } = { 
                quantityInStock: FieldValue.increment(item.quantity) 
            };
            
            const totalItemsInPurchase = purchase.items.reduce((sum, i) => sum + i.quantity, 0);
            if (totalItemsInPurchase > 0) {
              const landedCostPerUnitInPurchase = purchase.totalAmount / totalItemsInPurchase;
              const newItemsValue = landedCostPerUnitInPurchase * item.quantity;
              const oldStockValue = (product.purchasePrice || 0) * (product.quantityInStock);
              const newTotalStock = product.quantityInStock + item.quantity;
              
              if (newTotalStock > 0) {
                const newAveragePurchasePrice = (oldStockValue + newItemsValue) / newTotalStock;
                if (isFinite(newAveragePurchasePrice) && newAveragePurchasePrice > 0) {
                    stockUpdate.purchasePrice = newAveragePurchasePrice;
                }
              }
            }
            
            transaction.update(productRef, stockUpdate);
          }
        }
      });
  
      revalidateTag('purchases');
      revalidateTag('products');
      revalidateTag('dashboard-stats');
      return { success: true };
  
    } catch (error) {
      console.error('Failed to receive purchase:', error);
      const message = error instanceof Error ? error.message : 'Erreur DB: Impossible de réceptionner l\'achat.';
      return { success: false, message };
    }
}

export async function cancelPurchase(id: string) {
  const session = await getSession();
  if (session?.role !== 'Admin' && session?.role !== 'SuperAdmin') {
    return { message: "Action non autorisée." };
  }

  try {
    const purchaseToCancel = await getPurchaseById(id);
    if (!purchaseToCancel) {
      throw new Error("Achat non trouvé pour l'annulation.");
    }
    
    if (purchaseToCancel.status === 'Received' && session?.role !== 'SuperAdmin') {
      return { success: false, message: "Impossible d'annuler un achat déjà réceptionné."}
    }
    
    await updatePurchaseInDB(id, { status: 'Cancelled' });

    revalidateTag('purchases');
    revalidateTag('products');
    revalidateTag('dashboard-stats');
    return { success: true };
  } catch (error) {
    console.error("Échec de l'annulation de l'achat:", error);
    const message = error instanceof Error ? error.message : "Erreur DB: Impossible d'annuler l'achat.";
    return { success: false, message };
  }
}
